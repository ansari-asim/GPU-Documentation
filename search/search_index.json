{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Network","text":""},{"location":"#configuring-system-network","title":"Configuring System Network","text":""},{"location":"#cli","title":"CLI","text":"<p>Step 1: Open the terminal on your system.</p> <p>Step 2: Run the command to list your network interfaces:</p> <pre><code>nmcli device\n</code></pre> <p>This will show you the names of your network interfaces, e.g. enp0s3, wlp2s0, etc.</p> <p>Step 3: Run the following command to edit the connection settings for your desired interface (replace enp0s3 with your interface name):</p> <pre><code>nmcli connection edit enp0s3\n</code></pre> <p>Step 4: In the nmcli interactive prompt, set the new IP address, subnet mask, gateway, and DNS servers:</p> <pre><code>nmcli&gt; set ipv4.method manual\nnmcli&gt; set ipv4.addresses 192.168.1.100/24\nnmcli&gt; set ipv4.gateway 192.168.1.1\nnmcli&gt; set ipv4.dns 8.8.8.8,8.8.4.4\nnmcli&gt; quit\n</code></pre> <p>Note: Replace the IP addresses, subnet mask, gateway, and DNS servers with your desired values.</p> <p>Step 5: Activate the new configuration:</p> <pre><code>nmcli connection up enp0s3\n</code></pre> <p>Step 6: Verify your new IP Address configuration </p> <pre><code>ip addr show enp0s3\n</code></pre> <p>If everything went well, you should see your new IP address.</p>"},{"location":"#gui","title":"GUI","text":"<p>Step 1: Open Settings:</p> <ul> <li>Click on the system menu at the top right corner of your screen.</li> <li>Select \"Settings\" from the dropdown menu.</li> </ul> <p></p> <p>Step 2: Navigate to Network Settings:</p> <ul> <li>In the \"Settings\" window, find and click on the \"Network\" section on the left sidebar.</li> <li>In the \"Network\" settings, under the \"Wired\" section, click on the settings icon (gear icon) next to the \"Wired\" connection.</li> </ul> <p></p> <p>Step 3:  Network Configuration</p> <ul> <li>In the new window that appears, click on the \"IPv4\" tab to open the IPv4 settings.</li> <li>Change the \"IPv4 Method\" from \"Automatic (DHCP)\" to \"Manual\" by selecting the \"Manual\" radio button.</li> <li>Under the \"Addresses\" section, you need to provide the following information:<ul> <li>Address: Enter the IP address you want to assign to your machine. For example, <code>192.168.0.101</code>.</li> <li>Netmask: Enter the subnet mask. In this example, it's <code>255.255.255.0</code>.</li> <li>Gateway: Enter the gateway address, typically the address of your router. For this example, it is <code>192.168.0.1</code>.</li> </ul> </li> <li>Once you've entered all the necessary information, click the \"Apply\" button at the top right corner of the window to save the changes.</li> </ul> <p></p> <p>Step 4: Reconnect the Wired Connection:</p> <ul> <li>Ensure your cable is plugged in if not already.</li> <li>If the cable is unplugged, plug it back in, and your system should now use the manual IP configuration you set.</li> </ul>"},{"location":"#connect-two-different-network-in-gpu","title":"Connect two Different Network in GPU","text":""},{"location":"#cli_1","title":"CLI","text":"<p>Step 1: Identify Network Interfaces:</p> <ul> <li>Identify your network interfaces to distinguish between the USB dongle and the LAN connection.</li> </ul> <pre><code>ip link show\n</code></pre> <ul> <li>Note: the interface names (e.g., eth0, eth1, wlan0, usb0).</li> </ul> <p>Step 2: Configure Static IP for USB Dongle (Internet Access)</p> <p>Assuming your USB dongle is recognized as usb0, configure it with a static IP address.</p> <ul> <li>Open the Netplan configuration file</li> </ul> <pre><code>sudo nano /etc/netplan/01-netcfg.yaml    \n</code></pre> <ul> <li>Add the following configuration for the USB dongle.</li> </ul> <pre><code>network:\n   version: 2\n   ethernets:\n      usb0:\n      addresses:\n         - 192.168.2.10/24    # Example: Replace with your desired static IP address\n      gateway4: 192.168.2.1   # Example: Replace with your gateway\n      nameservers:\n         addresses:\n            - 8.8.8.8\n            - 8.8.4.4\n</code></pre> <p>Step 3: Configure Static IP for LAN Connection (Camera Access)</p> <p>Assuming your LAN interface is eth0, configure it with a static IP address.</p> <ul> <li>Open the Netplan configuration file.</li> </ul> <pre><code>sudo nano /etc/netplan/01-netcfg.yaml\n</code></pre> <ul> <li>Add the following configuration for the LAN connection</li> </ul> <pre><code>network:\n  version: 2\n  ethernets:\n    eth0:\n      addresses:\n        - 192.168.1.10/24     # Example: Replace with your desired static IP address\n      gateway4: 192.168.1.1   # Example: Replace with your gateway\n      nameservers:\n        addresses:\n          - 8.8.8.8\n          - 8.8.4.4\n</code></pre> <p>Step 4: Apply the Netplan Configuration</p> <ul> <li>Apply the Netplan configuration to enable the new network settings.</li> </ul> <pre><code>sudo netplan apply\n</code></pre> <p>Step 4: Verify Connections</p> <p>Ensure both interfaces are correctly configured and active.</p> <ul> <li>Check the status of the network interfaces.</li> </ul> <pre><code>ip a\n</code></pre> <ul> <li>Test the internet connection (via USB dongle).</li> </ul> <pre><code>ping -c 4 google.com\n</code></pre> <ul> <li>Test the camera network connection (via LAN)</li> </ul> <pre><code>ping -c 4 192.168.1.20\n</code></pre> <p>Troubleshooting</p> <p>If you encounter issues, you can troubleshoot using the following commands:    - Check Netplan configuration:</p> <pre><code>sudo netplan try\n</code></pre> <ul> <li>Restart network services:</li> </ul> <pre><code>sudo systemctl restart systemd-networkd\nsudo systemctl restart NetworkManager\n</code></pre> <ul> <li>Review system logs for network-related errors:</li> </ul> <pre><code>sudo journalctl -u systemd-networkd\nsudo journalctl -u NetworkManager\n</code></pre> <p>Example Netplan Configuration File</p> <p>Here is an example of how your /etc/netplan/01-netcfg.yaml file should look with both configurations:</p> <pre><code>network:\n  version: 2\n  ethernets:\n    usb0:\n      addresses:\n        - 192.168.2.10/24  # Example: Replace with your desired static IP address\n      gateway4: 192.168.2.1  # Example: Replace with your gateway\n      nameservers:\n        addresses:\n          - 8.8.8.8\n          - 8.8.4.4\n    eth0:\n      addresses:\n        - 192.168.1.10/24  # Example: Replace with your desired static IP address\n      gateway4: 192.168.1.1  # Example: Replace with your gateway\n      nameservers:\n        addresses:\n          - 8.8.8.8\n          - 8.8.4.4\n\n</code></pre>"},{"location":"#gui_1","title":"GUI","text":"<p>Step 1: Open Network Settings</p> <ul> <li>Click on the Network icon in the system tray.</li> <li>Select Settings.</li> </ul> <p>Step 2: Configure LAN Connection for Camera Access</p> <ul> <li>Open Wired Settings</li> <li>Click on the gear icon next to your wired connection (e.g., eth0).</li> </ul> <p></p> <p>IPv4 Settings</p> <ul> <li>Go to the IPv4 tab.</li> <li>Select Manual for the IPv4 Method.</li> <li>Under Addresses, enter:<ul> <li>Address: 192.168.1.10 (Replace with your desired static IP)</li> <li>Netmask: 255.255.255.0 (Common subnet mask)</li> <li>Gateway: 192.168.1.1 (Your network gateway)</li> </ul> </li> <li>Under DNS, enter:<ul> <li>8.8.8.8, 4.2.2.2 (Public DNS servers)</li> </ul> </li> <li>Click Apply to save the settings.</li> </ul> <p> </p> <p>Step 3:  Configure USB Dongle for Internet Access</p> <ul> <li>Open USB Ethernet Settings:<ul> <li>In the Network settings, find your USB Ethernet connection (it might be listed under a different name depending on your USB dongle).</li> </ul> </li> <li>Edit USB Ethernet Connection:<ul> <li>Click on the gear icon next to your USB Ethernet connection (e.g., usb0).</li> </ul> </li> </ul> <p></p> <p>IPv4 Settings</p> <ul> <li>Select Manual for the IPv4 Method.</li> <li>Under Addresses, enter:</li> <li>Go to the IPv4 tab.<ul> <li>Address: 192.168.2.10 (Replace with your desired static IP)</li> <li>Netmask: 255.255.255.0 (Common subnet mask)</li> <li>Gateway: 192.168.2.1 (Your network gateway)</li> </ul> </li> <li>Under DNS, enter:<ul> <li>8.8.8.8, 4.2.2.2 (Public DNS servers)</li> </ul> </li> <li>Click Apply to save the settings.</li> </ul> <p></p> <p>Step 4: Verify Network Connections</p> <ul> <li>Run the following command in the terminal:</li> </ul> <pre><code>ping -c 4 google.com\n</code></pre> <p>Ensure you receive responses.</p> <ul> <li>Test Camera Network Connection (via LAN):</li> <li>Ping the camera's IP address:</li> </ul> <pre><code>ping -c 4 &lt;camera-ip-address&gt;\n</code></pre> <ul> <li>Replace camera-ip-address with the actual IP address of your camera.</li> </ul>"},{"location":"#cctv-configuration","title":"CCTV Configuration","text":"<ul> <li> <p>When configuring CCTV for video analytics, follow these steps to ensure proper setup and functionality</p> </li> <li> <p>Ensure Network Compatibility</p> </li> <li> <p>Check Network Alignment: Verify that the CCTV network is on the same network as the GPU.</p> </li> <li>Adjust GPU Network Configuration: If the GPU is not on the same network as the CCTV, reconfigure the GPU to be in the same network as the CCTV.</li> <li> <p>DVR Network Configuration: </p> <p>If there is a need to configure the DVR network, follow these steps:</p> <ul> <li>Log in to the DVR via its IP address.   #Add Image here </li> <li>Go to the Configuration section.</li> <li>Navigate to Network.</li> <li>Select Basic Setting.</li> <li>Change the IP address as required.</li> </ul> </li> </ul> <p> </p> <ol> <li> <p>Configure DVR Video Encoding Settings</p> <p>Access DVR Settings:</p> <ul> <li>Open a web browser and enter the IP address of the DVR.</li> <li>Log in using the appropriate username and password.</li> </ul> <p>Navigate to Configuration:</p> <ul> <li>Go to the Configuration section.</li> <li>Select Video/Audio to access the encoding settings.</li> </ul> <p>Set Encoding Parameters:</p> <ul> <li>Adjust the video encoding settings as required. </li> </ul> <p>Note:-The specific settings will depend on your video analytics requirements and the capabilities of your DVR.</p> </li> </ol>"},{"location":"#vpn","title":"VPN","text":"<p>A Virtual Private Network (VPN) is a service that encrypts your internet connection and routes it through a remote server, masking your IP address and enhancing your online privacy and security. It allows you to access the internet as if you were in a different location, bypassing geo-restrictions and protecting your data from hackers and surveillance</p>"},{"location":"#tunnel-vpn","title":"Tunnel VPN","text":"<p>A Tunnel VPN (Virtual Private Network) refers to the method of securely transmitting data between two points (e.g., your device and a VPN server) by creating an encrypted \"tunnel\" over a public network such as the internet. This tunnel ensures that the data sent and received is protected from interception and unauthorized access, thereby enhancing privacy and security.</p> <p>Key features of Tunnel VPN include:</p> <ul> <li>Encryption: Data is encrypted, making it unreadable to anyone who intercepts it.</li> <li>Authentication: Only authorized users can establish a connection through the tunnel.</li> <li>Data Integrity: Ensures that data is not tampered with during transmission.</li> </ul> <p>Tunnel VPNs are commonly used to secure connections over public Wi-Fi, access region-restricted content, and protect sensitive information from cyber threats.</p> <p>Configuring a Tunnel VPN using FortiClient involves several steps, including installing the software, configuring the VPN settings, and connecting to the VPN. </p> <p>Below is a step-by-step guide to help you configure FortiClient for Tunnel VPN on your system:</p> <p>Step 1: Download and Install FortiClient</p> <p>Download FortiClient:</p> <ul> <li> <p>Visit the Fortinet website and navigate to the FortiClient download page.</p> </li> <li> <p>Choose the appropriate version for your operating system (Windows, macOS, Linux, etc.).</p> </li> </ul> <p>Install FortiClient:</p> <ul> <li> <p>Run the installer file you downloaded.</p> </li> <li> <p>Follow the on-screen instructions to complete the installation process.</p> </li> </ul> <p>Step 2: Configure VPN Settings</p> <p>Open FortiClient:</p> <ul> <li>Launch the FortiClient application.</li> </ul> <p>Access VPN Configuration:</p> <ul> <li>On the FortiClient main screen, select the \"Remote Access\" tab.</li> </ul> <p>Create a New VPN Connection:</p> <ul> <li>Click on the \"Configure VPN\" or \"New Connection\" button.</li> <li>Choose \"SSL-VPN\" or \"IPsec VPN\" based on your network's configuration.</li> </ul> <p>Enter VPN Details:</p> <ul> <li>Connection Name: Enter a name for your VPN connection (e.g., \"Work VPN\").</li> <li>Remote Gateway: Enter the IP address or hostname of your VPN server.</li> <li>Port: Use the default port or the one provided by your network administrator.</li> <li>Username and Password: Enter your VPN credentials (provided by your network administrator).</li> </ul> <p>Save the Configuration:</p> <ul> <li>Click \"Save\" or \"OK\" to save your VPN settings.</li> </ul> <p>Step 3: Connect to the VPN</p> <p>Connect to the VPN:</p> <ul> <li>On the FortiClient main screen, navigate to the \"Remote Access\" tab.</li> <li>Select the VPN connection you created from the dropdown menu.</li> <li>Click the \"Connect\" button.</li> </ul> <p>Authenticate:</p> <ul> <li>If prompted, enter your username and password.</li> <li>Complete any additional authentication steps if required (e.g., two-factor authentication).</li> </ul> <p>Verify the Connection:</p> <ul> <li>Once connected, the FortiClient interface will show the status as \"Connected\".</li> <li>You can now access resources on the remote network as if you were directly connected to it.</li> </ul> <p>Step 4: Disconnect from the VPN</p> <p>Disconnect:</p> <ul> <li>When you are done using the VPN, go back to the FortiClient application.</li> <li>Click the \"Disconnect\" button on the \"Remote Access\" tab.</li> </ul>"},{"location":"FAQ/","title":"FAQ","text":"<p>What should be the ideal camera configuration?</p> <p>A 2MP camera is generally sufficient for most AI-based applications. However, higher resolutions can improve detection accuracy and detail.</p> <p>What camera configurations are suitable for AI?</p> <p>Any camera with a resolution above 2MP is recommended for AI solutions, as it provides the clarity and data needed for accurate analysis.</p> <p>What is the minimum required internet bandwidth?</p> <p>A minimum of 10Mbps upload speed is needed to handle 5 cameras. For each additional camera, add 0.35Mbps. The download speed should consistently be 10Mbps or higher for optimal performance.</p> <p>What is the standard lead time for GPU orders?</p> <p>The typical lead time for GPU delivery is 2 weeks from the date of the purchase order (PO).</p> <p>How do you connect a GPU with an NVR/DVR or cameras?</p> <p>Both the GPU and NVR/DVR need to be on the same local network, typically bridged via a network switch.</p> <p>Can cameras be directly accessed through an NVR or DVR?</p> <p>Yes, cameras can be accessed through an NVR/DVR, but a network switch is required to connect the GPU and the NVR/DVR.</p> <p>Can an IP camera be directly connected to the GPU?</p> <p>Yes, IP cameras can be connected directly to the GPU, but a network switch is needed for the connection.</p> <p>What types of deployments does Assert AI offer?</p> <p>Assert AI provides both cloud-based and edge-based AI deployment options.</p> <p>What security certifications does Assert AI hold?</p> <p>Assert AI is certified for VAPT (Vulnerability Assessment and Penetration Testing), ISMS 27001, and SOC2 compliance.</p> <p>What is the effective range of your AI solution?</p> <p>Our AI solution is effective up to 75% of the camera\u2019s focal distance.</p> <p>What types of cameras does your solution support?</p> <p>We support a variety of camera types, including dome, bullet, unifocal, bifocal, and PTZ (pan-tilt-zoom) cameras.</p> <p>What are the camera bandwidth requirements?</p> <p>A bandwidth of 4Mbps is required to access a single camera when using multi-stream mode.</p> <p>Can all devices be connected wirelessly?</p> <p>While wireless connections are possible, we recommend wired connections due to enhanced security and better performance. Wireless connections may pose security risks and lead to reduced performance.</p>"},{"location":"GPU/","title":"GPU","text":""},{"location":"GPU/#jetson-device","title":"Jetson Device","text":""},{"location":"GPU/#avermedia-nano","title":"Avermedia (Nano)","text":"<p>Before proceeding, ensure you have the following:</p> <ul> <li>Jetson Nano device</li> <li>Avermedia EN715 board</li> <li>USB cable for putting the device into recovery mod</li> <li>Require Host PC Ubuntu 18.04 or Ubuntu 20.04</li> </ul> <p>Step 1: Download the BSP File</p> <p>Download the required BSP (Board Support Package) file for the Avermedia EN715 board from the following link :</p> <p>Download BSP File</p> <p>Step 2: Extract the BSP File</p> <p>Once the BSP file has been downloaded, open a terminal on your host machine and navigate to the directory where the file is located.</p> <p>Run the following command to extract the BSP file:</p> <pre><code>sudo tar xzvf EN715-R1.0.20.4.6.tar.gz\n</code></pre> <p>Step 3: Put Jetson Nano into Recovery Mode</p> <p>To flash the BSP file onto the Jetson Nano, you need to put the device into recovery mode.</p> <p>Steps to enter Recovery Mode:</p> <ul> <li>Connect the Jetson Nano to your host PC using a micro-USB cable.</li> <li>Press and hold the Recovery button.</li> <li>While holding the Recovery button, press the Power button.</li> <li>Release the Recovery button.</li> </ul> <p>Step 4: Run Flashing Commands</p> <ul> <li>Navigate to the directory</li> </ul> <pre><code>cd JetPack_4.6_Linux_JETSON_NANO_TARGETS/Linux_for_Tegra\n</code></pre> <ul> <li>Run the setup script</li> </ul> <pre><code>sudo ./setup.sh \n</code></pre> <ul> <li> <p>When prompted, select Raspberry_Pi_v2 by entering 7.</p> </li> <li> <p>Run the flashing command</p> </li> </ul> <pre><code>sudo ./install.sh\n</code></pre>"},{"location":"GPU/#avermedia-nx","title":"Avermedia (NX)","text":"<p>Before proceeding, ensure you have the following:*</p> <ul> <li>Jetson NX device</li> <li>Avermedia EN715 board</li> <li>USB cable for putting the device into recovery mod</li> <li>Require Host PC Ubuntu 18.04 or Ubuntu 20.04</li> </ul> <p>Step 1: Download the BSP File</p> <p>Download the required BSP (Board Support Package) file for the Avermedia EN715 board from the following link :</p> <p>Download BSP File</p> <p>Step 2: Extract the BSP File</p> <p>Once the BSP file has been downloaded, open a terminal on your host machine and navigate to the directory where the file is located.</p> <p>Run the following command to extract the BSP file:</p> <pre><code>sudo tar zxf EN715-NX-R1.0.22.4.6.tar.gz\n</code></pre> <p>Step 3: Put Jetson NX into Recovery Mode</p> <p>To flash the BSP file onto the Jetson NX, you need to put the device into recovery mode.</p> <p>Steps to enter Recovery Mode:</p> <ul> <li>Connect the Jetson NX to your host PC using a micro-USB cable.</li> <li>Press and hold the Recovery button. </li> <li>While holding the Recovery button, press the Power button.</li> <li>Release the Recovery button.</li> </ul> <p>Step 4: Run Flashing Commands</p> <ul> <li>Navigate to the directory</li> </ul> <pre><code>cd JetPack_4.6_Linux_JETSON_XAVIER_NX_TARGETS/Linux_for_Tegra\n</code></pre> <ul> <li>Run the setup script</li> </ul> <pre><code>sudo ./setup.sh \n</code></pre> <ul> <li> <p>When prompted, select Raspberry_Pi_v2 by entering 7.</p> </li> <li> <p>Run the flashing command</p> </li> </ul> <pre><code>sudo ./install.sh\n</code></pre>"},{"location":"GPU/#avermedia-tx2nx","title":"Avermedia (TX2NX)","text":"<p>Before proceeding, ensure you have the following:*</p> <ul> <li>Jetson TX2NX device</li> <li>Avermedia EN715 board</li> <li>USB cable for putting the device into recovery mod</li> <li>Require Host PC Ubuntu 18.04 or Ubuntu 20.04</li> </ul> <p>Step 1: Download the BSP File</p> <p>Download the required BSP (Board Support Package) file for the Avermedia EN715 board from the following link :</p> <p>Download BSP File</p> <p>Step 2: Extract the BSP File</p> <p>Once the BSP file has been downloaded, open a terminal on your host machine and navigate to the directory where the file is located.</p> <p>Run the following command to extract the BSP file:</p> <pre><code>sudo tar zxf EN715-TX2-NX-R1.0.4.4.6.tar.gz\n</code></pre> <p>Step 3: Put Jetson NX into Recovery Mode</p> <p>To flash the BSP file onto the Jetson TX2NX, you need to put the device into recovery mode.</p> <p>Steps to enter Recovery Mode:</p> <ul> <li>Connect the Jetson TX2NX to your host PC using a micro-USB cable.</li> <li>Press and hold the Recovery button. </li> <li>While holding the Recovery button, press the Power button.</li> <li>Release the Recovery button.</li> </ul> <p>Step 4: Run Flashing Commands</p> <ul> <li>Navigate to the directory</li> </ul> <pre><code>cd JetPack_4.6_Linux_JETSON_TX2_TARGETS/Linux_for_Tegra\n</code></pre> <ul> <li>Run the setup script</li> </ul> <pre><code>sudo ./setup.sh \n</code></pre> <ul> <li> <p>When prompted, select Raspberry_Pi_v2 by entering 7.</p> </li> <li> <p>Run the flashing command</p> </li> </ul> <pre><code>sudo ./install.sh\n</code></pre>"},{"location":"GPU/#eagletech-101","title":"Eagletech-101","text":"<p>Preloaded OS Information</p> <ul> <li>OS: Preloaded with BSP</li> <li>Username: nvidia</li> <li>Password: nvidia</li> </ul> <p>Prerequisites</p> <ul> <li>Eagle-101 with Jetson Nano Module</li> <li>Require Host PC Ubuntu 18.04</li> </ul> <p>Step 1: Download Required Files</p> <p>Download the following two files from the NVIDIA Developer Portal</p> <ul> <li>Jetson-210_Linux_R32.7.2_aarch64.tbz2</li> <li>Tegra_Linux_Sample-Root-Filesystem_R32.7.2_aarch64.tbz2</li> </ul> <p>Step 2: Decompress Image File on Host PC</p> <ul> <li>Open a terminal on your host PC (Ubuntu 18.04).</li> <li>Decompress the Jetson Linux file:</li> </ul> <pre><code>tar xf jetson-210_Linux_R32.7.2_aarch64.tbz2\n</code></pre> <ul> <li>Navigate to the root filesystem directory:</li> </ul> <pre><code>cd Linux_for_Tegra/rootfs/\n</code></pre> <ul> <li>Decompress the root filesystem into the rootfs/ directory:</li> </ul> <pre><code>sudo tar xpf /path/to/Tegra_Linux_Sample-Root-Filesystem_R32.7.2_aarch64.tbz2\n</code></pre> <ul> <li> <p>Replace /path/to/ with the actual path to the downloaded file.</p> </li> <li> <p>Move back to the Linux_for_Tegra/ directory:</p> </li> </ul> <pre><code>cd ..\n</code></pre> <ul> <li>Apply Binaries</li> </ul> <pre><code>sudo ./apply_binaries.sh\n</code></pre> <p>Step 3: Copy Device Tree File</p> <p>Download dtb File</p> <p>Copy the necessary device tree file to the appropriate directory:</p> <pre><code>cp tegra210-p3448-0002-p3449-0000-b00.dtb Linux_for_Tegra/kernel/dtb/\n</code></pre> <p>Step 4: Flash Image and Boot the Device</p> <ul> <li>Put the Jetson Nano into Force Recovery Mode:<ul> <li>On the Eagle-101 board, short the 3-pin (FC REC) and 4-pin (GND)</li> <li>Connect the Micro USB to your host PC.</li> </ul> </li> <li>Run the flash command in the Linux_for_Tegra/ directory:</li> </ul> <pre><code>sudo ./flash.sh jetson-nano-emmc mmcblk0p1\n</code></pre>"},{"location":"GPU/#developer-kit","title":"Developer-Kit","text":"<p>Hardware Setup</p> <ul> <li>Jetson Nano Developer Kit: Comes with the board, heat sink, and ports pre-mounted.</li> <li>MicroSD Card (minimum 32 GB recommended): For OS and application storage.</li> <li>5V/4A Power Supply: Required for powering the board. Optionally, you can use micro-USB power for low-power projects.</li> <li>HDMI or DisplayPort Monitor: For display output.</li> <li>USB Keyboard and Mouse: For input.</li> </ul> <p>Flashing the OS</p> <ul> <li> <p>Download, install, and launch Etcher</p> </li> <li> <p>Download the Jetson Nano Developer Kit SD Card Image, and note where it was saved on the computer.</p> </li> <li> <p>Click \u201cSelect image\u201d and choose the zipped image file downloaded earlier.</p> </li> <li> <p>Click \u201cFlash!\u201d Your OS may prompt for your username and password before it allows Etcher to proceed.</p> </li> <li> <p>It will take Etcher 10-15 minutes to write and validate the image if your microSD card is connected via USB 3.0</p> </li> <li> <p>After Etcher finishes, eject the SD Card using Files application</p> </li> <li> <p>Physically remove microSD card from the computer.</p> </li> </ul> <p>3. First Boot Setup</p> <ul> <li> <p>Insert the microSD card into the Jetson Nano.</p> </li> <li> <p>Power on the Jetson Nano by plugging in the power supply.</p> </li> <li> <p>The system will boot into the NVIDIA JetPack OS, which is based on Ubuntu 18.04.</p> </li> <li> <p>Follow the on-screen instructions to set up the system, including:</p> <ul> <li>Username and password creation (default for tutorials: nvidia/nvidia).</li> <li>Setting up network access (Wi-Fi via USB dongle or Ethernet).</li> </ul> </li> </ul>"},{"location":"GPU/#tacodi","title":"Tacodi","text":"<p>Prerequisites</p> <ul> <li>Host PC: Ubuntu 18.04</li> <li>NVIDIA SDK Manager: Installed on the host PC</li> <li>USB-to-USB Cable: To connect the Tacodi board to the host PC</li> <li>JetPack 4.6.5: Downloaded and installed via SDK Manager</li> </ul> <p>Step 1: Install NVIDIA SDK Manager</p> <ul> <li> <p>Download the NVIDIA SDK Manager from the official NVIDIA Developer website</p> </li> <li> <p>Open a terminal and install the SDK Manager:</p> </li> </ul> <pre><code>sudo apt install ./sdkmanager_*.deb\n</code></pre> <ul> <li> <p>Replace sdkmanager_*.deb with the actual filename of the SDK Manager installer.</p> </li> <li> <p>Launch the SDK Manager:</p> </li> </ul> <p>Step 2: Download JetPack</p> <ul> <li>Open the SDK Manager and log in using your NVIDIA Developer account.</li> <li>Under JetPack in the SDK Manager, select JetPack 4.6 from the available options.</li> <li>Choose the target hardware as Jetson Nano .</li> <li>Click Download and Install to download the necessary JetPack components and flash tools.</li> </ul> <p>Step 3: Connect the Tacodi Board</p> <ul> <li>Connect the Tacodi board to your host PC using a USB-to-USB cable.</li> <li>Connect the jumper to put board into force recovery mode</li> <li>Power on the Tacodi board.</li> </ul> <p>Step 4: Flash the Device</p> <ul> <li>In the SDK Manager, navigate to the Flash section.</li> <li>Select your device from the list of connected devices.</li> <li>Click Flash to begin the process</li> <li>Enter the host system password </li> <li>Enter the Jetson username and password which you want to set (By default is nvidia/nvidia)  </li> </ul>"},{"location":"GPU/#os-transfer","title":"OS Transfer","text":"<p>When flashing the Jetson SOM (System on Module), the operating system is initially installed on the eMMC. If you need to transfer the OS to an SSD or SD card, follow these steps</p> <p>Format the SSD or sd card</p> <pre><code>sudo mkfs -t ext4 /dev/nvme0n1\nsudo fdisk /dev/nvme0n1\nsudo mkfs -t ext4 /dev/nvme0n1p1\n</code></pre> <p>Download and Extract Required Files</p> <p>Download the provided ZIP file. After extracting it, you will find two important shell scripts:</p> <ul> <li><code>copy-rootfs-ssd.sh</code></li> <li><code>setup-service.sh</code></li> </ul> <p>Run the Scripts</p> <ul> <li> <p>Run the copy-rootfs-ssd.sh script to copy the root filesystem to the SSD or SD card.</p> </li> <li> <p>After that, run the setup-service.sh script to configure the necessary services for booting from the SSD or SD card.</p> </li> </ul> <p>Reboot Device</p> <p>Once the scripts have been executed successfully, restart the system.</p> <p>Verify the Transfer</p> <p>After rebooting, run the following command to check if the operating system is now running from the SSD or SD card:</p> <pre><code>df -h\n</code></pre>"},{"location":"GPU/#dgpu","title":"dGPU","text":""},{"location":"GPU/#ubuntu-2004","title":"Ubuntu 20.04","text":"<p>Dual Boot Setup: Installing Ubuntu 20.04 Alongside Windows</p> <p>Prerequisites</p> <ul> <li>USB Drive (8 GB or larger): To create a bootable Ubuntu 20.04 installation media.</li> <li>Ubuntu 20.04 ISO File: Download the Ubuntu 20.04 LTS ISO.</li> <li>Rufus : For creating a bootable USB drive.</li> </ul> <p>Step 1: Create a Bootable USB</p> <ul> <li>Download and install Rufus </li> <li>Insert the USB drive into your system and open Rufus:<ul> <li>Select your USB drive.</li> <li>Choose the downloaded Ubuntu 20.04 ISO as the image.</li> <li>Ensure Partition Scheme is set to GPT and Target System to UEFI.</li> </ul> </li> <li>Click Start and wait for the bootable USB to be created.</li> </ul> <p>Step 2: Prepare Windows for Dual Boot</p> <ul> <li>Free Up Disk Space for Ubuntu</li> <li>Go to Disk Management</li> <li>Right-click on your main Windows partition (usually C:) and select Shrink Volume.</li> <li>Shrink the partition by the amount of space you want to allocate for Ubuntu (minimum 25 GB recommended)</li> </ul> <p>Step 3: Boot from the USB Drive</p> <ul> <li>Reboot your system and enter the BIOS/UEFI settings by pressing a specific key (usually F2, F10, DEL, or Esc) during startup.</li> <li>Disable the Secure boot </li> <li>Change the boot order to boot from the USB drive.</li> <li>Save and exit BIOS/UEFI settings. </li> </ul> <p>The system will now boot from the Ubuntu installation USB.</p> <p>Step 4: Install Ubuntu 20.04</p> <ul> <li>Once the system boots from the USB, you will be prompted with the Ubuntu installation screen. Select Install Ubuntu to begin the installation process.</li> </ul> <p>During Installation</p> <ul> <li> <p>Select Your Language and click Continue.</p> </li> <li> <p>On the Keyboard Layout screen, select your preferred layout and continue.</p> </li> <li> <p>Updates and Software: Choose whether to install third-party software for graphics, Wi-Fi hardware, and additional media formats.</p> </li> <li> <p>In the Installation Type screen, select Install Ubuntu alongside Windows Boot Manager (this option should appear if Windows is detected).</p> <ul> <li>If this option doesn\u2019t appear, choose Something else and manually allocate partitions (refer to the advanced guide below).</li> </ul> </li> <li> <p>Allocate Space for Ubuntu:</p> <ul> <li>Allocate the free space you created earlier for Ubuntu installation.</li> <li>Ensure you create at least:<ul> <li>A root partition (/) with ext4 file system (25 GB+ recommended).</li> </ul> </li> </ul> </li> <li> <p>Time Zone: Select your location for the correct time zone and click Continue</p> </li> <li>Create User Account: Enter your name, computer name, username, and password.</li> <li>Click Install Now to begin the installation. Confirm the partition changes when prompted</li> </ul> <p>Step 5: Post-Installation Setup</p> <ul> <li> <p>After installation completes, remove the USB drive and restart the computer.</p> </li> <li> <p>The GRUB Bootloader menu will appear at startup, allowing you to choose between Ubuntu and Windows.</p> </li> </ul>"},{"location":"GPU/#ubuntu-2204","title":"Ubuntu 22.04","text":"<p>Dual Boot Setup: Installing Ubuntu 22.04 Alongside Windows</p> <p>Prerequisites</p> <ul> <li>USB Drive (8 GB or larger): To create a bootable Ubuntu 22.04 installation media.</li> <li>Ubuntu 22.04 ISO File: Download the Ubuntu 22.04 LTS ISO.</li> <li>Rufus : For creating a bootable USB drive.</li> </ul> <p>Step 1: Create a Bootable USB</p> <ul> <li>Download and install Rufus </li> <li>Insert the USB drive into your system and open Rufus:<ul> <li>Select your USB drive.</li> <li>Choose the downloaded Ubuntu 22.04 ISO as the image.</li> <li>Ensure Partition Scheme is set to GPT and Target System to UEFI.</li> </ul> </li> <li>Click Start and wait for the bootable USB to be created.</li> </ul> <p>Step 2: Prepare Windows for Dual Boot</p> <ul> <li>Free Up Disk Space for Ubuntu</li> <li>Go to Disk Management</li> <li>Right-click on your main Windows partition (usually C:) and select Shrink Volume.</li> <li>Shrink the partition by the amount of space you want to allocate for Ubuntu (minimum 25 GB recommended)</li> </ul> <p>Step 3: Boot from the USB Drive</p> <ul> <li>Reboot your system and enter the BIOS/UEFI settings by pressing a specific key (usually F2, F10, DEL, or Esc) during startup.</li> <li>Disable the Secure boot </li> <li>Change the boot order to boot from the USB drive.</li> <li>Save and exit BIOS/UEFI settings. </li> </ul> <p>The system will now boot from the Ubuntu installation USB.</p> <p>Step 4: Install Ubuntu 22.04</p> <ul> <li>Once the system boots from the USB, you will be prompted with the Ubuntu installation screen. Select Install Ubuntu to begin the installation process.</li> </ul> <p>During Installation</p> <ul> <li> <p>Select Your Language and click Continue.</p> </li> <li> <p>On the Keyboard Layout screen, select your preferred layout and continue.</p> </li> <li> <p>Updates and Software: Choose whether to install third-party software for graphics, Wi-Fi hardware, and additional media formats.</p> </li> <li> <p>In the Installation Type screen, select Install Ubuntu alongside Windows Boot Manager (this option should appear if Windows is detected).</p> <ul> <li>If this option doesn\u2019t appear, choose Something else and manually allocate partitions (refer to the advanced guide below).</li> </ul> </li> <li> <p>Allocate Space for Ubuntu:</p> <ul> <li>Allocate the free space you created earlier for Ubuntu installation.</li> <li>Ensure you create at least:<ul> <li>A root partition (/) with ext4 file system (25 GB+ recommended).</li> </ul> </li> </ul> </li> <li> <p>Time Zone: Select your location for the correct time zone and click Continue</p> </li> <li>Create User Account: Enter your name, computer name, username, and password.</li> <li>Click Install Now to begin the installation. Confirm the partition changes when prompted</li> </ul> <p>Step 5: Post-Installation Setup</p> <ul> <li> <p>After installation completes, remove the USB drive and restart the computer.</p> </li> <li> <p>The GRUB Bootloader menu will appear at startup, allowing you to choose between Ubuntu and Windows.</p> </li> </ul>"},{"location":"SOP/","title":"SOP","text":"<p>Standard Operating Procedure (SOP) for GPU Installation and Maintenance</p>"},{"location":"SOP/#environment-setup-for-gpu-installation","title":"Environment Setup for GPU Installation","text":"<p>Designated Area</p> <ul> <li>A) Ensure the GPU and device are placed in a neat and clean environment to remain dust-free.</li> <li>B) If such an environment is unavailable, install a rack system.</li> </ul> <p>Rack Requirements</p> <ul> <li> <p>Water-Resistant and Dust-Proof Racks:</p> </li> <li> <p>For Jetson Devices: Use a 2U rack.</p> </li> <li>For RTX GPUs: Use a 12U rack.</li> </ul> <p>Power Requirements &amp; Socket Specifications</p> <ul> <li>For Jetson Devices: Requires a 5 Amp socket.</li> <li>For RTX GPUs: Requires a 16 Amp socket.</li> </ul>"},{"location":"SOP/#gpu-installation-process","title":"GPU Installation Process","text":"<p>Power Down and Open Case</p> <ol> <li>Shut down the computer and unplug it from the wall.</li> <li>Press the power button for a few seconds to discharge any remaining electricity.</li> <li>Open the case by unscrewing or releasing the side panel.</li> </ol> <p>Identify PCIe Slot</p> <ul> <li>Locate the primary PCIe x16 slot (usually the top slot closest to the CPU).</li> </ul> <p>Prepare the Case</p> <ul> <li>Remove the expansion slot covers on the case corresponding to the GPU.</li> </ul> <p>Insert the GPU</p> <ol> <li>Line up the GPU\u2019s PCIe connector with the slot.</li> <li>Gently press down until you hear a click from the retention clip.</li> <li>Secure the GPU bracket to the case using screws.</li> </ol> <p>Connect Power Cables</p> <ul> <li>Connect the PCIe power cables from the PSU to the GPU (6-pin, 8-pin, or both, depending on the GPU).</li> <li>Ensure the connections are firm and secure.</li> </ul> <p>Close the Case and Power Up</p> <ol> <li>Replace the side panel and screw it back into place.</li> <li>Plug the system back into the wall and power it on.</li> </ol>"},{"location":"SOP/#servicing-and-maintenance","title":"Servicing and Maintenance","text":"<p>Service Frequency</p> <ul> <li>Devices must be serviced every 3 months to ensure optimal performance and longevity.</li> </ul> <p>Steps for Servicing</p> <ol> <li> <p>Cabinet Cleaning</p> <ul> <li>Use a soft fabric or tissue to clean the cabinet exterior and interior.</li> <li>Remove any accumulated dust or dirt.</li> </ul> </li> <li> <p>Dust Removal</p> <ul> <li>Use a blower to clean the machine thoroughly, including all visible and hidden areas.</li> </ul> </li> <li> <p>RAM Cleaning</p> <ul> <li>Remove the RAM modules carefully.</li> <li>Inspect for any carbon deposits or residue.</li> <li>If carbon is detected, clean the contacts gently using a rubber eraser.</li> </ul> </li> <li> <p>GPU Cleaning</p> <ul> <li>Detach the GPU from the motherboard carefully.</li> <li>Check for carbon deposits or residue on the GPU contacts.</li> <li>Clean the contacts gently using a rubber eraser.</li> </ul> </li> <li> <p>Fan Cleaning</p> <ul> <li>Use a blower to clean the fans thoroughly.</li> <li>Ensure no dust or debris remains.</li> </ul> </li> <li> <p>Fan Net Cleaning</p> <ul> <li>Clean the fan nets using a combination of a blower and soft fabric.</li> <li>Ensure the nets are free of any blockages.</li> </ul> </li> </ol> <p>Additional Checks During Servicing</p> <ul> <li>Inspect the power sockets and connectors for wear and tear.</li> <li>Ensure all screws and fittings in the racks are securely fastened.</li> <li>Verify that the fans are running smoothly without noise or obstruction.</li> </ul> <p>Notes</p> <ul> <li>Always handle components with care to avoid static damage.</li> <li>Ensure proper ventilation during installation and servicing to avoid overheating.</li> </ul>"},{"location":"SOP/#videos","title":"Videos","text":"<p>How to clean the PC Cabinet</p> <p>How to install the Graphics Card</p> <p>How to Clean the Graphics Card</p> <p>How to remove RAM</p> <p>How to clean RAM</p>"},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#daddy-ai","title":"daddy-ai","text":"<p>Installation</p> <p>To install daddy-ai, use pip:</p> <pre><code>pip install daddy-ai\n</code></pre> <p>Import the DeployMaster</p> <p>In your Python script, import the DeployMaster class:</p> <pre><code>from daddy_ai.deploy_master import DeployMaster\nimport os\n</code></pre> <p>Initialize DeployMaster</p> <p>Create an instance of DeployMaster:</p> <pre><code>deploy_master = DeployMaster(user=os.getenv(\"USER\"))\n</code></pre> <p>Create a Bash Script</p> <p>Use the create_bash method to create a bash script for your Python application:</p> <pre><code>script_file = deploy_master.create_bash(\n    path=\"/path/to/your/app\",\n    command=\"python3 your_app.py\",\n    code_name=\"your_app_name\"\n)\n</code></pre> <p>Generate Restart Code</p> <p>Generate a restart script that will manage your application's runtime:</p> <pre><code>deploy_master.generate_restart_code(\n    start_time=\"09:00:00\",\n    end_time=\"17:00:00\",\n    process_name=\"your_app.py\",\n    script_file=script_file\n)\n</code></pre> <p>Create a Service</p> <pre><code>deploy_master.create_service()\n</code></pre> <p>File Locations</p> <ul> <li>Bash scripts: /home/{user}/daddy-ai/scripts/run_{code_name}.sh</li> <li>Restart Python scripts: /home/{user}/daddy-ai/scripts/restart_{code_name}.py</li> <li>Service files: /etc/systemd/system/daddy-ai-deploy-master-{code_name}.service</li> </ul>"},{"location":"deployment/#jtop","title":"jtop","text":"<p>Key Features of jtop</p> <ul> <li>Real-time system monitoring: Displays real-time statistics of CPU, GPU, and memory usage.</li> <li>Temperature monitoring: Tracks the temperature of the CPU, GPU, and other critical components.</li> <li>Power consumption: Provides insights into power usage to help optimize energy efficiency.</li> <li>Resource management: Helps you identify resource bottlenecks.</li> <li>NVIDIA-specific metrics: Shows Jetson-specific details like the status of the Tensor cores and GPU load.</li> </ul> <p>Installation Steps</p> <p>The jtop utility is part of the jetson-stats package. Install it using pip:</p> <pre><code>sudo pip3 install -U jetson-stats\n</code></pre> <p>Verify Installation</p> <p>After the installation, you can check the version to ensure everything is installed properly:</p> <pre><code>jtop --version\n</code></pre> <p>Running jtop</p> <pre><code>sudo jtop\n</code></pre> <p>This will launch the jtop interface, displaying a comprehensive overview of the Jetson system's performance metrics.</p> <p>How to Use jtop</p> <p>Basic Interface</p> <p>When you launch jtop, you'll see a terminal-based dashboard with real-time statistics:</p> <ul> <li>Top bar: Displays general system information, including uptime, CPU usage, memory usage, and temperature.</li> <li>Main area: Contains various performance metrics like<ul> <li>CPU: Shows the load on each CPU core.</li> <li>GPU: Displays the GPU load and status of the CUDA cores.</li> <li>Memory: Provides details on RAM and swap usage.</li> <li>Temperature: Tracks the temperature of different components.</li> <li>Power consumption: Indicates how much power the device is drawing.</li> </ul> </li> </ul> <p>Additional Features  - Process Monitoring: Similar to htop, jtop allows you to monitor running processes  - Power Mode Adjustment:  You can adjust the power mode of your Jetson device directly from the jtop interface. This helps in optimizing performance and power consumption.  - Log Data: You can log system data for later analysis by running jtop in logging mode.</p> <p>Logging System Stats</p> <p>You can log system statistics by using jtop's logging functionality. This is especially helpful for performance analysis and troubleshooting:</p> <pre><code>sudo jtop --log &lt;filename&gt;\n</code></pre>"},{"location":"deployment/#dependencies","title":"Dependencies","text":"<p>System Update and Upgrade</p> <pre><code>sudo apt update -y\nsudo apt upgrade -y\n</code></pre> <p>Install Python and Development Tools</p> <pre><code>sudo apt install python3-pip -y\nsudo apt-get install python3-dev default-libmysqlclient-dev build-essential -y\n</code></pre> <p>MySQL Installation and Python MySQL Packages</p> <pre><code>sudo apt-get install mysql-server -y\nsudo pip3 uninstall mysql-connector &amp;&amp; sudo pip3 install mysql-connector\nsudo pip3 install mysql-connector-python\nsudo pip3 install mysqlclient\n</code></pre> <p>Install and Manage AWS SDK (Boto3)</p> <pre><code>sudo pip3 uninstall boto3 &amp;&amp; sudo pip3 uninstall boto3\nsudo pip3 install boto3\nsudo pip3 install boto3 botocore awscli --ignore-installed\n</code></pre> <p>Install psutil for System Monitoring</p> <pre><code>sudo pip3 uninstall psutil &amp;&amp; sudo pip3 uninstall psutil\nsudo pip3 install psutil\n</code></pre> <p>Install GStreamer and Plugins for Multimedia Processing</p> <pre><code>sudo apt install \\\nlibssl1.0.0 \\\nlibgstreamer1.0-0 \\\ngstreamer1.0-tools \\\ngstreamer1.0-plugins-good \\\ngstreamer1.0-plugins-bad \\\ngstreamer1.0-plugins-ugly \\\ngstreamer1.0-libav \\\nlibgstrtspserver-1.0-0 \\\nlibjansson4=2.11-1 -y\n</code></pre> <p>Install nano Text Editor</p> <pre><code>sudo apt install nano -y\n</code></pre> <p>Install gdown for Google Drive File Downloads</p> <pre><code>sudo pip3 install gdown\n</code></pre>"},{"location":"monitoring/","title":"Monitoring","text":"<p>Dependencies</p> <pre><code>\nsudo apt install smartmontools ifstat -y\n\nsudo apt install python3-pip\n\npip3 install psutil pytz watchdog\n\nsudo apt-get install lm-sensors\n\n</code></pre>"},{"location":"monitoring/#network-monitoring","title":"Network Monitoring","text":"<p>This script logs network usage periodically by executing the ifstat command every 30 seconds and saving the output to a rotating log file named network.log. It uses Python's subprocess module to run shell commands, pytz for timezone handling, and logging for capturing and rotating logs efficiently.</p> <pre><code>import subprocess\nimport datetime\nimport pytz\nimport logging\nfrom logging.handlers import RotatingFileHandler\nimport time\n\nist = pytz.timezone('Asia/Kolkata')  \n\n# Set up logging\ndef setup_logging(log_filename):\n    logger = logging.getLogger(log_filename)\n    logger.setLevel(logging.INFO)\n    handler = RotatingFileHandler(log_filename, maxBytes=10 * 1024 * 1024, backupCount=10)\n    formatter = logging.Formatter('%(asctime)s - %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    return logger\n\n# Log network monitoring data\ndef log_network_usage(net_logger):\n    while True:\n        try:\n            timestamp = datetime.datetime.now(ist).strftime(\"%Y-%m-%d %H:%M:%S IST\")  \n            result = subprocess.run(['ifstat', '30', '1'], capture_output=True, text=True)\n            if result.returncode == 0:\n                net_logger.info(f\"[{timestamp}] {result.stdout.strip()}\")\n            else:\n                net_logger.error(f\"Error: {result.stderr}\")\n        except Exception as e:\n            net_logger.error(f\"Exception occurred: {e}\")\n        time.sleep(30)\n\nif __name__ == \"__main__\":\n    net_logger = setup_logging('network.log')\n    log_network_usage(net_logger)\n</code></pre>"},{"location":"monitoring/#temperature-monitoring","title":"Temperature Monitoring","text":"<p>This script monitors system metrics, including CPU and GPU temperatures, CPU utilization, and RAM usage, logging the data every 30 seconds into a rotating log file named temperature.log. It leverages subprocess for executing shell commands and logging for efficient log management.</p> <pre><code>import subprocess\nimport datetime\nimport pytz\nimport psutil\nimport logging\nfrom logging.handlers import RotatingFileHandler\nimport time\n\nist = pytz.timezone('Asia/Kolkata') \n\n# Set up logging\ndef setup_logging(log_filename):\n    logger = logging.getLogger(log_filename)\n    logger.setLevel(logging.INFO)\n    handler = RotatingFileHandler(log_filename, maxBytes=10 * 1024 * 1024, backupCount=10)\n    formatter = logging.Formatter('%(asctime)s - %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    return logger\n\n# Log temperatures and system utilization\ndef log_temperatures(temp_logger):\n    while True:\n        try:\n            try:\n                cpu_temp_output = subprocess.check_output([\"sensors\"], text=True).strip()\n            except FileNotFoundError:\n                cpu_temp_output = \"sensors command not found\"\n\n            # Check for the NVIDIA GPU temperature\n            try:\n                gpu_temp_output = subprocess.check_output(\n                    [\"nvidia-smi\", \"--query-gpu=temperature.gpu\", \"--format=csv,noheader,nounits\"], text=True\n                ).strip()\n            except FileNotFoundError:\n                gpu_temp_output = \"nvidia-smi command not found\"\n\n            cpu_utilization = psutil.cpu_percent(interval=1)\n            ram_utilization = psutil.virtual_memory().percent\n            timestamp = datetime.datetime.now(ist).strftime(\"%Y-%m-%d %H:%M:%S IST\")\n\n            temp_logger.info(\n                f\"Timestamp IST: {timestamp}, CPU Temp: {cpu_temp_output}, GPU Temp: {gpu_temp_output}, \"\n                f\"CPU Utilization: {cpu_utilization}%, RAM Utilization: {ram_utilization}%\"\n            )\n        except Exception as e:\n            temp_logger.error(f\"Unexpected error: {e}\")\n        time.sleep(30)\n\nif __name__ == \"__main__\":\n    temp_logger = setup_logging('temperature.log')\n    log_temperatures(temp_logger)\n\n</code></pre>"},{"location":"monitoring/#disk-monitoring","title":"Disk Monitoring","text":"<p>This Python script monitors disk usage on the system every 5 minutes, logging both the total and free disk space for each partition. If disk usage exceeds a specified threshold (default 90%), it generates a warning in the log file</p> <pre><code>import psutil\nimport time\nimport logging\nfrom logging.handlers import RotatingFileHandler\n\n# Log disk usage\ndef monitor_disk_usage(disk_logger, threshold=90):\n    while True:\n        for part in psutil.disk_partitions():\n            usage = psutil.disk_usage(part.mountpoint)\n            total_gb = usage.total / (1024 ** 3)\n            free_gb = usage.free / (1024 ** 3)\n            used_gb = total_gb - free_gb\n            disk_logger.info(f\"Disk usage on {part.mountpoint}: {usage.percent}% used, {used_gb:.2f} GB used, {free_gb:.2f} GB remaining out of {total_gb:.2f} GB total\")\n            if usage.percent &gt;= threshold:\n                disk_logger.warning(f\"Disk usage alert on {part.mountpoint}: {usage.percent}% used, {used_gb:.2f} GB used, {free_gb:.2f} GB remaining out of {total_gb:.2f} GB total\")\n        time.sleep(300)  \n\n# Setup logging function\ndef setup_logging(log_filename):\n    logger = logging.getLogger(log_filename)\n    logger.setLevel(logging.INFO)\n    handler = RotatingFileHandler(log_filename, maxBytes=10 * 1024 * 1024, backupCount=10)\n    formatter = logging.Formatter('%(asctime)s - %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    return logger\n\nif __name__ == \"__main__\":\n    # Setup disk usage logger\n    disk_logger = setup_logging('disk_usage.log')\n\n    # Start disk usage monitoring\n    monitor_disk_usage(disk_logger)\n\n\n</code></pre>"},{"location":"monitoring/#cache-monitoring","title":"Cache Monitoring","text":"<p>This Python script monitors and logs the cache memory usage of the system every 5 Minutes, saving the data in a rotating log file. If an error occurs while fetching the memory status, it logs the error message in the same file.</p> <pre><code>\nimport psutil\nimport time\nimport logging\nfrom logging.handlers import RotatingFileHandler\n\n# Log config\nLOG_MAX_SIZE = 10 * 1024 * 1024  # 10 MB for general monitoring logs\nLOG_BACKUP_COUNT = 10\n\n# Setup logging function\ndef setup_logging(log_filename):\n    logger = logging.getLogger(log_filename)\n    logger.setLevel(logging.INFO)\n    handler = RotatingFileHandler(log_filename, maxBytes=LOG_MAX_SIZE, backupCount=LOG_BACKUP_COUNT)\n    formatter = logging.Formatter('%(asctime)s - %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    return logger\n\n# Log cache memory status\ndef log_cache_memory_status(cache_logger):\n    while True:\n        try:\n            mem_info = psutil.virtual_memory()\n            cache_logger.info(f\"Cache memory: {mem_info.cached / 1024 / 1024} MB\")\n        except Exception as e:\n            cache_logger.error(f\"Error fetching cache memory status: {e}\")\n        time.sleep(300)\n\nif __name__ == \"__main__\":\n    # Setup logger for cache memory monitoring\n    cache_logger = setup_logging('cache_memory.log')\n\n    # Start cache memory monitoring\n    log_cache_memory_status(cache_logger)\n\n</code></pre>"},{"location":"monitoring/#ssd-monitoring","title":"SSD Monitoring","text":"<p>This script leverages smartctl (a command-line utility for monitoring storage devices) to check the health of an NVMe SSD. The output from the smartctl command is parsed to extract relevant health metrics, including temperature, available spare, usage percentage, read/write data, and more. This information is essential for ensuring the SSD is in good condition and to detect potential issues before they affect performance.</p> <pre><code>import psutil\nimport subprocess\nimport time\nimport datetime\nimport pytz\nimport logging\nfrom logging.handlers import RotatingFileHandler\n\n# Log config\nLOG_MAX_SIZE = 10 * 1024 * 1024  # 10 MB for general monitoring logs\nLOG_BACKUP_COUNT = 10\n\n# Set the timezone to UTC\nIST = pytz.timezone('Asia/Kolkata')\n\n# Setup logging function\ndef setup_logging(log_filename):\n    logger = logging.getLogger(log_filename)\n    logger.setLevel(logging.INFO)\n    handler = RotatingFileHandler(log_filename, maxBytes=LOG_MAX_SIZE, backupCount=LOG_BACKUP_COUNT)\n    formatter = logging.Formatter('%(asctime)s - %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    return logger\n\n# Auto-detect SSD and run smartctl\ndef detect_ssd_and_log_smartctl(smartctl_logger):\n    while True:\n        ssd_path = None\n        for disk in psutil.disk_partitions(all=False):\n            if 'nvme' in disk.device or 'sd' in disk.device:\n                ssd_path = disk.device.replace('/dev/', '')\n                break\n\n        if ssd_path:\n            try:\n                timestamp = datetime.datetime.now(IST).strftime(\"%Y-%m-%d %H:%M:%S IST\")\n                result = subprocess.run(['sudo','smartctl', '-a', f'/dev/{ssd_path}'], capture_output=True, text=True)\n\n                if result.returncode == 0:\n                    smartctl_logger.info(f\"Timestamp: {timestamp}\\n{result.stdout}\")\n                    print(f\"Logged smartctl data for {ssd_path} at {timestamp}\")\n                else:\n                    error_message = f\"Error running smartctl for {ssd_path}: {result.stderr}\"\n                    smartctl_logger.error(error_message)\n                    print(error_message)\n\n            except Exception as e:\n                error_message = f\"Exception occurred while running smartctl for {ssd_path}: {e}\"\n                smartctl_logger.error(error_message)\n                print(error_message)\n        else:\n            smartctl_logger.warning(\"No SSD detected.\")\n            print(\"No SSD detected.\")\n        time.sleep(300)  \n\nif __name__ == \"__main__\":\n    # Setup SSD health monitoring logger\n    smartctl_logger = setup_logging('smartctl.log')\n\n    # Start SSD health monitoring\n    detect_ssd_and_log_smartctl(smartctl_logger)\n\n</code></pre>"},{"location":"sdk/","title":"SDK","text":""},{"location":"sdk/#jetson-device","title":"Jetson Device","text":""},{"location":"sdk/#avermedia-tacodi","title":"Avermedia &amp; Tacodi","text":"<p>Update and Install JetPack Dependencies</p> <pre><code>sudo apt update &amp;&amp; apt depends nvidia-jetpack | awk '{print $2}' | uniq | xargs -I {} bash -c \"sudo apt clean ; sudo apt install -y {}\"\n</code></pre> <p>Explanation:</p> <ul> <li>apt depends nvidia-jetpack: Lists all the dependencies required by the nvidia-jetpack package.</li> <li>awk '{print $2}': Extracts only the package names</li> <li>uniq: Removes duplicate entries from the package list.</li> <li>xargs -I {} bash -c \"sudo apt clean ; sudo apt install -y {}\":<ul> <li>apt clean: Clears the package cache to free up space before the installation.</li> <li>apt install -y {}: Installs each package found in the dependency list without asking for confirmation.</li> </ul> </li> </ul> <p>Purpose: This command updates your system and ensures all necessary JetPack dependencies are freshly installed.</p> <p>Remove Unnecessary or Old Packages</p> <pre><code>sudo apt autoremove --purge libnvidia-container0 libnvidia-container-tools nvidia-container-csv-cuda nvidia-container-csv-cudnn nvidia-container-csv-tensorrt nvidia-container-csv-visionworks nvidia-container-runtime nvidia-container-toolkit nvidia-docker2 cuda-toolkit-10-2 libcudnn8 libcudnn8-dev libcudnn8-samples libopencv libopencv-dev libopencv-python libopencv-samples opencv-licenses graphsurgeon-tf libnvinfer8 libnvinfer-bin libnvinfer-dev libnvinfer-doc libnvinfer-plugin8 libnvinfer-plugin-dev libnvinfer-samples libnvonnxparsers8 libnvonnxparsers-dev libnvparsers8 libnvparsers-dev python3-libnvinfer python3-libnvinfer-dev tensorrt uff-converter-tf libvisionworks libvisionworks-dev libvisionworks-samples libvisionworks-sfm libvisionworks-sfm-dev libvisionworks-tracking libvisionworks-tracking-dev libnvvpi1 vpi1-dev vpi1-samples vpi1-demos nvidia-l4t-jetson-multimedia-api -y\n</code></pre> <p>Explanation:</p> <ul> <li>sudo apt autoremove: Automatically removes packages that were installed as dependencies but are no longer required.</li> <li>--purge: Ensures that not only are the packages removed but also their associated configuration files.</li> <li>The list of packages includes various older or unnecessary libraries and tools (like CUDA 10.2, cuDNN, TensorRT, OpenCV, VisionWorks, etc.) that are specific to Jetson development.</li> <li>-y: Runs the command without prompting for confirmation.</li> </ul> <p>Purpose: This step clears out any outdated or unneeded packages and configurations, ensuring that only necessary software remains on the device.</p> <p>Reinstall JetPack Dependencies</p> <pre><code>sudo apt update &amp;&amp; apt depends nvidia-jetpack | awk '{print $2}' | uniq | xargs -I {} bash -c \"sudo apt clean ; sudo apt install -y {}\"\n</code></pre> <p>Explanation:</p> <p>This command repeats the process of the first command:</p> <ul> <li>Updates the system package list.</li> <li>Re-fetches the dependencies for nvidia-jetpack.</li> <li>Clears cached files (apt clean).</li> <li>Reinstalls the necessary packages with apt install.</li> </ul> <p>Purpose: After purging old or unnecessary packages in the second step, this step ensures that the Jetson device is updated with all the required JetPack dependencies, ensuring a clean and functional setup.</p> <p>Note: </p> <ul> <li> <p>The above documentation applies to Nano, NX, and TX2NX devices using Avermedia and  Tacodi carrier boards. </p> </li> <li> <p>For Eagletech boards, please refer to the next documentation. </p> </li> </ul>"},{"location":"sdk/#eagletech","title":"Eagletech","text":"<p>Update and Install JetPack Dependencies</p> <pre><code>sudo apt update &amp;&amp; apt depends nvidia-jetpack | awk '{print $2}' | uniq | xargs -I {} bash -c \"sudo apt clean ; sudo apt install -y {}\"\n</code></pre> <p>Explanation:</p> <ul> <li>Updates the package list and installs the necessary JetPack dependencies.</li> <li>Cleans up the package cache to free space during installation.</li> </ul> <p>Reboot The GPU</p> <pre><code>sudo reboot\n</code></pre> <p>Update the System:</p> <pre><code>sudo apt update -y\n</code></pre> <p>Install python , gdown and nano</p> <pre><code>sudo apt install python3-pip -y\nsudo pip3 install gdown\nsudo apt install nano -y\n</code></pre> <p>Source .bashrc and Change Directory to Home</p> <ul> <li>Source the .bashrc to apply any environment changes and move to the home directory.</li> </ul> <pre><code>source ~/.bashrc\necho \"Changing directory to home\"\ncd ~\n</code></pre> <p>Install Additional Dependencies</p> <ul> <li>Install various system libraries and GStreamer plugins required for DeepStream.</li> </ul> <pre><code>sudo apt install \\\nlibssl1.0.0 \\\nlibgstreamer1.0-0 \\\ngstreamer1.0-tools \\\ngstreamer1.0-plugins-good \\\ngstreamer1.0-plugins-bad \\\ngstreamer1.0-plugins-ugly \\\ngstreamer1.0-libav \\\nlibgstrtspserver-1.0-0 \\\nlibjansson4=2.11-1 -y\n</code></pre> <p>Create Directory for DeepStream 6.0</p> <ul> <li>Create a directory for DeepStream 6.0 and copy necessary libraries.</li> </ul> <pre><code>sudo mkdir -p /opt/nvidia/deepstream/deepstream-6.0/lib\nsudo cp /usr/local/lib/librdkafka* /opt/nvidia/deepstream/deepstream-6.0/lib\n</code></pre> <p>Reboot The GPU</p> <pre><code>sudo reboot\n</code></pre>"},{"location":"sdk/#deepstream-60","title":"Deepstream 6.0","text":"<p>Downloading DeepStream 6.0</p> <pre><code>sudo gdown 1RnLnqyooOM9CU7KA8BJ7_uteARUzsJJG\n</code></pre> <p>Installing DeepStream 6.0</p> <pre><code>sudo apt-get install -y ./deepstream-6.0_6.0.0-1_arm64.deb\n</code></pre>"},{"location":"sdk/#python-apps","title":"Python-apps","text":"<p>Navigate to DeepStream Sources Directory</p> <pre><code>cd /opt/nvidia/deepstream/deepstream/sources/\n</code></pre> <p>Clone the deepstream_python_apps Repository</p> <pre><code>sudo git clone https://github.com/NVIDIA-AI-IOT/deepstream_python_apps.git\ncd deepstream_python_apps/\n</code></pre> <p>Checkout the Specific Version for DeepStream 6.0</p> <pre><code>sudo git checkout 20c6b13671e81cf73ca98fa795f84cab7dd6fc67\n</code></pre> <p>Initialize Git Submodules</p> <pre><code>cd bindings/\nsudo git submodule update --init\n</code></pre> <p>Create and Navigate to Build Directory</p> <pre><code>sudo mkdir build &amp;&amp; cd build\n</code></pre> <p>Run CMake with Specific Options</p> <pre><code>sudo cmake .. -DPYTHON_MAJOR_VERSION=3 -DPYTHON_MINOR_VERSION=6 -DPIP_PLATFORM=linux_aarch64 -DDS_PATH=/opt/nvidia/deepstream/deepstream\n</code></pre> <p>Build the Python Bindings</p> <pre><code>sudo make -j$(nproc)\n</code></pre> <p>Copy the Python Wheel File to Export Directory</p> <pre><code>sudo cp pyds-*.whl /export_pyds\n</code></pre> <p>Install the Python Wheel Package</p> <pre><code>sudo python3 -m pip install --upgrade pip\nsudo pip3 install ./pyds-1.1.0-py3-none*.whl\n</code></pre> <p>Running DeepStream Analytics Application</p> <pre><code>cd /opt/nvidia/deepstream/deepstream-6.2/sources/deepstream_python_apps/apps/deepstream-nvdsanalytics/\nsudo python3 deepstream_nvdsanalytics.py file:/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4\n</code></pre>"},{"location":"sdk/#dgpu","title":"dGPU","text":""},{"location":"sdk/#cuda-118","title":"CUDA 11.8","text":"<p>Select NVIDIA Driver 535</p> <ul> <li> <p>Open Ubuntu Software \u2192 Additional Drivers.</p> </li> <li> <p>Select NVIDIA driver 535 from the list and apply the changes.</p> </li> <li> <p>Restart your system for the changes to take effect.</p> </li> </ul> <p>Installing Dependencies</p> <pre><code>sudo apt install -y \\\nlibssl1.1 \\\nlibgstreamer1.0-0 \\\ngstreamer1.0-tools \\\ngstreamer1.0-plugins-good \\\ngstreamer1.0-plugins-bad \\\ngstreamer1.0-plugins-ugly \\\ngstreamer1.0-libav \\\nlibgstreamer-plugins-base1.0-dev \\\nlibgstrtspserver-1.0-0 \\\nlibjansson4 \\\nlibyaml-cpp-dev \\\nlibjsoncpp-dev \\\nprotobuf-compiler \\\ngcc \\\nmake \\\ngit \\\npython3\n</code></pre> <p>Explanation</p> <ul> <li>Installs required libraries and packages for DeepStream and GStreamer (used for media   handling in DeepStream).</li> <li>Development tools like gcc, make, and git are included for compilation and building purposes.</li> </ul> <p>Setting up CUDA 11.8 Repository</p> <pre><code>sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/3bf863cc.pub\nsudo add-apt-repository -y \"deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/ /\"\nsudo apt-get update -y\n</code></pre> <p>Explanation</p> <ul> <li>Adds the official NVIDIA CUDA 11.8 repository for Ubuntu 20.04.</li> <li>Fetches the GPG key for secure installation of CUDA packages.</li> </ul> <p>Installing CUDA Toolkit 11.8</p> <pre><code>sudo apt-get install -y cuda-toolkit-11-8\n</code></pre> <p>Explanation</p> <ul> <li>Installs CUDA toolkit version 11.8, which provides the necessary GPU libraries and tools.</li> </ul>"},{"location":"sdk/#tensorrt-851","title":"TensorRT 8.5.1","text":"<p>Installing NVIDIA TensorRT and Related Libraries</p> <pre><code>sudo apt-get install -y \\\nlibnvinfer8=8.5.1-1+cuda11.8 \\\nlibnvinfer-plugin8=8.5.1-1+cuda11.8 \\\nlibnvparsers8=8.5.1-1+cuda11.8 \\\nlibnvonnxparsers8=8.5.1-1+cuda11.8 \\\nlibnvinfer-bin=8.5.1-1+cuda11.8 \\\nlibnvinfer-dev=8.5.1-1+cuda11.8 \\\nlibnvinfer-plugin-dev=8.5.1-1+cuda11.8 \\\nlibnvparsers-dev=8.5.1-1+cuda11.8 \\\nlibnvonnxparsers-dev=8.5.1-1+cuda11.8 \\\nlibnvinfer-samples=8.5.1-1+cuda11.8 \\\nlibcudnn8=8.6.0.163-1+cuda11.8 \\\nlibcudnn8-dev=8.6.0.163-1+cuda11.8 \\\npython3-libnvinfer=8.5.1-1+cuda11.8 \\\npython3-libnvinfer-dev=8.5.1-1+cuda11.8\n</code></pre> <p>Explanation</p> <ul> <li>Installs TensorRT libraries (libnvinfer, libnvparsers, libcudnn) for optimizing deep learning inference, particularly on NVIDIA hardware.</li> <li>Specific version 8.5.1 of TensorRT is installed with CUDA 11.8 compatibility.</li> </ul> <p>Install Python gdown Tool</p> <pre><code>sudo apt-get install python3-pip\nsudo pip3 install gdown \n</code></pre>"},{"location":"sdk/#deepstream-62","title":"Deepstream 6.2","text":"<p>Downloading DeepStream 6.2</p> <pre><code>sudo gdown 1UHGdU5utMwAvwTa4_0a2U6ArH9tgTRub \n</code></pre> <p>Installing DeepStream 6.2</p> <pre><code>sudo apt-get install -y ./deepstream-6.2_6.2.0-1_amd64.deb\n</code></pre>"},{"location":"sdk/#python-apps_1","title":"Python-apps","text":"<p>Cloning DeepStream Python Applications Repository</p> <pre><code>cd /opt/nvidia/deepstream/deepstream-6.2/sources\ngit clone -b v1.1.6 https://github.com/NVIDIA-AI-IOT/deepstream_python_apps.git\n</code></pre> <p>Installing Python Development Packages</p> <pre><code>sudo apt install -y python3-gi python3-dev python3-gst-1.0 python-gi-dev \\\n    python3 python3-pip python3.8-dev cmake g++ build-essential \\\n    libglib2.0-dev libglib2.0-dev-bin libgstreamer1.0-dev libtool m4 \\\n    autoconf automake libgirepository1.0-dev libcairo2-dev\n</code></pre> <p>Explanation</p> <ul> <li>Installs essential Python and GStreamer libraries for Python bindings, including libgirepository, glib, and gstreamer components.</li> </ul> <p>Initialization of submodules</p> <p>This will create the following directory:</p> <pre><code>&lt;DeepStream 6.2 ROOT&gt;/sources/deepstream_python_apps\n</code></pre> <p>The repository utilizes gst-python and pybind11 submodules. To initializes them, run the following command:</p> <pre><code>cd /opt/nvidia/deepstream/deepstream/sources/deepstream_python_apps/\ngit submodule update --init\n</code></pre> <p>Installing Gst-python</p> <pre><code>sudo apt-get install -y apt-transport-https ca-certificates -y\nsudo update-ca-certificates\n</code></pre> <p>Building and Installing DeepStream Python Bindings</p> <pre><code>cd 3rdparty/gst-python/\n./autogen.sh\nmake -j$(nproc)\nsudo make install\n</code></pre> <p>Explanation</p> <ul> <li>Builds and installs the GStreamer Python bindings for DeepStream.</li> </ul> <pre><code>cd ../../bindings\nsudo mkdir build\ncd build\nsudo cmake ..\nsudo make -j$(nproc)\nsudo pip3 install pyds-1.1.6-py3-none-linux_x86_64.whl\n</code></pre> <p>Explanation</p> <ul> <li>Builds and installs the Python bindings for DeepStream (pyds).</li> </ul> <p>Running DeepStream Analytics Application</p> <pre><code>cd /opt/nvidia/deepstream/deepstream-6.2/sources/deepstream_python_apps/apps/deepstream-nvdsanalytics/\nsudo python3 deepstream_nvdsanalytics.py file:/opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4\n</code></pre>"},{"location":"sdk/#cuda-122","title":"CUDA 12.2","text":"<p>Prerequisites</p> <p>Install the following components:</p> <ul> <li> <p>Ubuntu 22.04</p> </li> <li> <p>GStreamer 1.20.3</p> </li> <li> <p>CUDA 12.2</p> </li> <li> <p>TensorRT  8.6.1.6</p> </li> </ul> <p>NVIDIA Driver:</p> <ul> <li>560.35.03 (for RTX GPUs)</li> </ul> <p>Remove Previous DeepStream Installations</p> <pre><code>sudo rm -rf /usr/local/deepstream /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libgstnv* /usr/bin/deepstream* \\\n/usr/lib/x86_64-linux-gnu/gstreamer-1.0/libnvdsgst* /usr/lib/x86_64-linux-gnu/gstreamer-1.0/deepstream* \\\n/opt/nvidia/deepstream/deepstream*\n</code></pre> <pre><code>sudo rm -rf /usr/lib/x86_64-linux-gnu/libv41/plugins/libcuvidv4l2_plugin.so\n</code></pre> <p>Migrate glib to a Newer Version</p> <p>Run the following commands:</p> <pre><code>pip3 install meson\npip3 install ninja\n</code></pre> <p>Compilation and Installation Steps</p> <pre><code>git clone https://github.com/GNOME/glib.git\ncd glib\ngit checkout &lt;glib-version-branch&gt;  # e.g., 2.76.6\nmeson build --prefix=/usr\nninja -C build/\ncd build/\nninja install\n</code></pre> <p>Verify the newly installed glib version:</p> <pre><code>pkg-config --modversion glib-2.0\n</code></pre> <p>Install Dependencies</p> <p>Run the following commands:</p> <pre><code>sudo apt install \\\nlibssl3 \\\nlibssl-dev \\\nlibgles2-mesa-dev \\\nlibgstreamer1.0-0 \\\ngstreamer1.0-tools \\\ngstreamer1.0-plugins-good \\\ngstreamer1.0-plugins-bad \\\ngstreamer1.0-plugins-ugly \\\ngstreamer1.0-libav \\\nlibgstreamer-plugins-base1.0-dev \\\nlibgstrtspserver-1.0-0 \\\nlibjansson4 \\\nlibyaml-cpp-dev \\\nlibjsoncpp-dev \\\nprotobuf-compiler \\\ngcc \\\nmake \\\ngit \\\npython3\n</code></pre> <pre><code>sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/3bf863cc.pub\n</code></pre> <pre><code>sudo add-apt-repository \"deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/ /\"\n</code></pre> <pre><code>sudo apt-get update\n</code></pre> <pre><code>sudo apt-get install cuda-toolkit-12-2\n</code></pre>"},{"location":"sdk/#tensorrt-8616","title":"TensorRT 8.6.1.6","text":"<pre><code>sudo apt-get install --no-install-recommends libnvinfer-lean8=8.6.1.6-1+cuda12.0 libnvinfer-vc-plugin8=8.6.1.6-1+cuda12.0 \\\nlibnvinfer-headers-dev=8.6.1.6-1+cuda12.0 libnvinfer-dev=8.6.1.6-1+cuda12.0 libnvinfer-headers-plugin-dev=8.6.1.6-1+cuda12.0 \\\nlibnvinfer-plugin-dev=8.6.1.6-1+cuda12.0 libnvonnxparsers-dev=8.6.1.6-1+cuda12.0 libnvinfer-lean-dev=8.6.1.6-1+cuda12.0 \\\nlibnvparsers-dev=8.6.1.6-1+cuda12.0 python3-libnvinfer-lean=8.6.1.6-1+cuda12.0 python3-libnvinfer-dispatch=8.6.1.6-1+cuda12.0 \\\nuff-converter-tf=8.6.1.6-1+cuda12.0 onnx-graphsurgeon=8.6.1.6-1+cuda12.0 libnvinfer-bin=8.6.1.6-1+cuda12.0 \\\nlibnvinfer-dispatch-dev=8.6.1.6-1+cuda12.0 libnvinfer-dispatch8=8.6.1.6-1+cuda12.0 libnvonnxparsers-dev=8.6.1.6-1+cuda12.0 \\\nlibnvonnxparsers8=8.6.1.6-1+cuda12.0 libnvinfer-vc-plugin-dev=8.6.1.6-1+cuda12.0 libnvinfer-samples=8.6.1.6-1+cuda12.0\n</code></pre>"},{"location":"sdk/#deepstream-70","title":"Deepstream 7.0","text":"<p>Downloading DeepStream 7.0</p> <pre><code>sudo gdown 1p7jUJmSVXmayGZNPQt8tQW6USHq9oORG\n</code></pre> <p>Installing DeepStream 7.0</p> <pre><code>sudo apt-get install -y ./deepstream-7.0_7.0.0-1_amd64.deb\n</code></pre>"},{"location":"sdk/#python-apps_2","title":"Python-apps","text":"<pre><code>cd /opt/nvidia/deepstream/deepstream-7.0/sources\ngit clone -b v1.1.11 https://github.com/NVIDIA-AI-IOT/deepstream_python_apps.git\n</code></pre> <p>Base dependencies</p> <pre><code>apt install python3-gi python3-dev python3-gst-1.0 python-gi-dev git meson \\\n    python3 python3-pip python3.10-dev cmake g++ build-essential libglib2.0-dev \\\n    libglib2.0-dev-bin libgstreamer1.0-dev libtool m4 autoconf automake libgirepository1.0-dev libcairo2-dev\n</code></pre> <p>Initialization of submodules</p> <pre><code>cd /opt/nvidia/deepstream/deepstream/sources/deepstream_python_apps/\ngit submodule update --init\n</code></pre> <p>Installing Gst-python</p> <pre><code>sudo apt-get install -y apt-transport-https ca-certificates -y\nsudo update-ca-certificates\n</code></pre> <p>Build and install gst-python:</p> <pre><code>cd 3rdparty/gstreamer/subprojects/gst-python/\nmeson setup build\ncd build\nninja\nninja install\n</code></pre> <p>Compiling the bindings</p> <pre><code>cd deepstream_python_apps/bindings\nmkdir build\ncd build\ncmake ..\nmake -j$(nproc)\n</code></pre> <p>Installing the bindings</p> <pre><code>pip3 install ./pyds-1.1.11-py3-none*.whl\n</code></pre> <p>pip wheel troubleshooting</p> <p>If the wheel installation fails, upgrade the pip using the following command:</p> <pre><code>python3 -m pip install --upgrade pip\n</code></pre> <p>Cuda-python</p> <pre><code>sudo pip3 install cuda-python\n</code></pre>"},{"location":"sdk/#uninstalling","title":"Uninstalling","text":"<p>Uninstalling Previous DeepStream and CUDA Libraries</p> <pre><code>sudo rm -rf /usr/local/deepstream /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libgstnv* /usr/bin/deepstream* /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libnvdsgst* /usr/lib/x86_64-linux-gnu/gstreamer-1.0/deepstream*  /opt/nvidia/deepstream/deepstream*\nsudo rm -rf /usr/lib/x86_64-linux-gnu/libv41/plugins/libcuvidv4l2_plugin.so\nsudo apt-get remove cuda* libnvinfer* -y \nsudo apt update -y\n</code></pre> <p>Explanation:</p> <ul> <li>Removes all existing DeepStream components, CUDA, TensorRT libraries, and plugins to ensure a clean environment.</li> <li>apt-get remove cuda libnvinfer uninstalls any existing CUDA and TensorRT installations.</li> </ul>"},{"location":"sdk/#docker-setup","title":"Docker Setup","text":"<p>Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.</p> <p>Add Docker's official GPG key:</p> <pre><code>sudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n</code></pre> <p>Add the repository to Apt sources:</p> <pre><code>echo \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <p>Install the Docker packages.</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <p>Verify that the Docker Engine installation is successful by running the hello-world image.</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>Install NVIDIA Container Toolkit:</p> <pre><code>sudo apt-get install -y nvidia-container-toolkit\n</code></pre> <p>Configure the NVIDIA runtime for Docker:</p> <pre><code>sudo nvidia-ctk runtime configure --runtime=docker\n</code></pre> <p>Restart Docker service:</p> <pre><code>sudo systemctl restart docker\n</code></pre> <p>Download the docker image</p> <p>Note: Please use a screen session for this downloading , because it takes a lot of time to download</p> <p>Upgrade and install gdown</p> <pre><code>sudo pip3 install --upgrade --no-cache-dir gdown\n</code></pre> <p>Download file from Google Drive using its ID:</p> <pre><code>gdown --id 1oWvWU7ft50TzbYCzhx_RcdoTZuLF8vhl \n</code></pre> <p>Load a Docker image from a tar file:</p> <pre><code>sudo docker load -i rajesh-ds-py.tar\n\n</code></pre>"}]}